{
    "collab_server" : "",
    "contents" : "library(tm)\nlibrary(wordcloud)\nlibrary(memoise)\nlibrary(markdown)\n\n###\n# Knygų sąrašas\n###\nbooks <<- list(\n  \"Vincas Mykolaitis-Putinas\" = \"altoriusesely\",\n  \"Balys Sruoga. Dievų miškas\" = \"dievumiskas\",\n  \"Ignas Šeinius. Kuprelis\" = \"kuprelis\"\n  \n)\n\n###\n# Patvirtina jeigu knyga yra sąraše\n###\nvalidateBook <- function (book){\n  if (!(book %in% books)){\n      stop(\"Tokios knygos sąraše nėra\")\n  }\n}\n\n###\n# Gauname knygos eilutes\n###\ngetBookLines <- memoise(function(book){\n  # Patvirtina knygą\n  validateBook(book)\n\n  # Pildo failo pavadinimą\n  fileName <- paste(c(\"data/\", book, \".txt\"), collapse = \"\")\n\n  # Skaito knygą iš failo\n  text.v <- scan(fileName, what=\"character\", sep=\"\\n\")\n\n  # Atpažįsta pirmą ir paskutinę eilutes\n  chapter.1.position <- grep(\"^CHAPTER 1\", text.v)\n  the.end.position <- grep(\"^THE END\", text.v)\n\n  text.v[chapter.1.position:the.end.position]\n})\n\n###\n# Gauname visą knygos tekstą\n###\ngetBookText <- memoise(function(book){\n  book.lines <- getBookLines(book)\n  paste(book.lines, collapse = \" \")\n})\n\n###\n# Gauname skyrių sąrašą\n###\ngetBookChapters <- function(book){\n\n  # Sukuria tuščią vektorių chapters\n  chapters <- c()\n\n  book.lines <- getBookLines(book)\n  book.lines.quantity <- length(book.lines)\n\n  chapter.positions <- grep(\"^CHAPTER \\\\d\", book.lines)\n  chapter.quantity <- length(chapter.positions)\n\n  for (i in 1:(chapter.quantity - 1)){\n\n      chapter.lines <- book.lines[chapter.positions[i]:chapter.positions[i + 1]]\n      chapter <- paste(chapter.lines, collapse = \" \")\n      chapters <- c(chapters, chapter)\n  }\n\n  # Prideda paskutinį skyrių\n  chapter.lines <- book.lines[chapter.positions[chapter.quantity]:book.lines.quantity]\n  chapter <- paste(chapter.lines, collapse = \" \")\n  chapters <- c(chapters, chapter)\n\n  \n  # Grąžina chapters\n  chapters\n}\n\ngetTermMatrixPerBook <- memoise(function(book, quantity){\n  \n  text <- getBookText(book)\n  matrix <- getTermMatrix(text)\n  matrix[1:quantity]\n})\n\ngetPerChapterDataFrame <- memoise(function(book, quantity){\n\n  # Ieško žodžių, kurios naudosime\n  text <- getBookText(book)\n  matrix <- getTermMatrix(text)\n  matrix <- matrix[1:quantity]\n  words <- names(matrix)\n\n  # Gauna chapters\n  chapters <- getBookChapters(book)\n\n  # Renka duomenis\n  chapterV <- c()\n  wordV <- c()\n  countV <- c()\n\n  for (j in 1:length(words)) {\n\n    word <- words[j]\n\n    for (i in 1:length(chapters)){\n\n      chapter <- chapters[i]\n      chapterMatrix <- getTermMatrix(chapter)\n\n      chapterV <- c(chapterV, i)\n      wordV <- c(wordV, word)\n\n      if (word %in% names(chapterMatrix)){\n\n        countV <- c(countV, chapterMatrix[[word]])\n\n      } else {\n\n        countV <- c(countV, 0)\n      }\n    }\n  }\n\n  # Data frame su duomenimis\n  df <- data.frame(chapter = chapterV, word = wordV, count = countV)\n  df$chapter <- as.factor(df$chapter)\n  df$word <- factor(df$word, levels = words)\n  df$count <- as.numeric(df$count)\n\n  df\n})\n\n###\n# Term Document Matrix\n###\ngetTermMatrix <- memoise(function(text) {\n\n  \n  corpus = Corpus(VectorSource(text))\n  # Visos raidės mažosios\n  corpus = tm_map(corpus, content_transformer(tolower))\n  # Panaikina kablelius\n  corpus = tm_map(corpus, removePunctuation)\n  # Panaikina skaicius\n  corpus = tm_map(corpus, removeNumbers)\n\n  myDTM =\n    TermDocumentMatrix(\n      corpus,\n      # Nustato mažiausią žodžio ilgį\n      control = list(wordLengths = c(6,Inf))\n    )\n  matrix = as.matrix(myDTM)\n\n  # Matricos rušiavimas\n  sort(rowSums(matrix), decreasing = TRUE)\n})\n",
    "created" : 1525004196563.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2437332180",
    "id" : "559BC605",
    "lastKnownWriteTime" : 1525302534,
    "last_content_update" : 1525302534117,
    "path" : "C:/Users/Tautvydas/Desktop/Bakalaurinis/Text-mining/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}